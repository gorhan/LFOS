[%
	var system := aScheduler.System;
	var task := aScheduler.taskset;
%]
from LFOS.Scheduler.Scheduler import Scheduler
from LFOS.Resource.Resource import *
from LFOS.Task.Task import *
from LFOS.Scheduling.Characteristic.Time import Time
from LFOS.macros import *

[%/*
	Resource-related concerns are handled and the corresponding code is generated.
*/%]
[%  
	var allResourceTypes = aScheduler.resourceTypes;
	var allResources = Sequence{system} + allResourceTypes.getResources(Sequence{ResourceAbstraction#ACTIVE, ResourceAbstraction#PASSIVE, ResourceAbstraction#COMPOSITE});

	for(resourceType in allResourceTypes) {%]
[%=resourceType.identifier%] = Type(ResourceTypeList.[%=resourceType.abstraction.asString()%], "[%=resourceType.identifier%]")
[%}%]

[%	for(resource in allResources.excluding(system)) {%]
[%=resource.getResourceVariableName()%] = ResourceFactory.create_instance([%=resource.belongs.identifier%], "[%=resource.name%]")
[%=resource.getResourceVariableName()%].set_capacity([%=resource.capacity%])
[%=resource.getResourceVariableName()%].set_mode(ModeTypeList.[%=resource.resourceMode.asString()%])
[%		if(resource.hasProperty("power")) {%]
[%=resource.generatePowerConsumptionCode()%]
[%		}%]

[%	}
	for(resource in allResources.select(r | r.hasProperty("exclusiveResources"))) {%]
[%=resource.generateExclusiveResourcesCode()%]
[%	}%]
[%=allResourceTypes.getResources(Sequence{ResourceAbstraction#COMPOSITE}).generateResourceTreeCode()%]

[%/*
	Task-related concerns are handled and the corresponding code is generated.
*/%]
[%	var tasks = aScheduler.taskset;
	for(task in aScheduler.taskset) {%]
[%=task.getTaskVariableName()%] = TaskFactory.create_instance([%=task.generateTaskConstructionCode(aScheduler.begin, aScheduler.begin+aScheduler.duration)%])
[%=task.generateResourceRequirementsCode()%]
[%	}%]

[%
	operation AbstractTask generateTaskConstructionCode(begin : Integer, end : Integer) : String {
		var parameters : Sequence(String) = Sequence{};
		
		parameters.add("name=" + "\"" + self.name + "\"");
		parameters.add("type" + "\"" + self.type + "\"");
		
		if(self.hasProperty("releaseTime"))
			parameters.add("phase=" + "Time(" + self.releaseTime + ")");
		else
			parameters.add("phase=" + "Time(0)");
		
		if(self.hasProperty("deadline"))
			parameters.add("phase=" + "Time(" + self.deadline + ")");
		else
			parameters.add("phase=" + "Time(" + end + ")");
			
		parameters.add("periodicity=" + "PeriodicityTypeList." + self.periodType.asString());
		
		if(self.hasProperty("priority"))
			parameters.add("priority=" + self.priorityValue);
		if(self.hasProperty("deadlineType"))
			parameters.add("deadline_type=" + "DeadlineRequirementTypeList." + self.deadlineType.asString());
		if(self.hasProperty("pmtnType"))
			parameters.add("preemptability=" + "PreemptionTypeList." + self.pmtnType.asString());
		
		if(not self.fires.isEmpty()) {
			var tokens = Map{};
			for(token in self.fires) {
				tokens.put("\"" + token.name + "\"", token.amount);
			}
			parameters.add("token_name=" + "[" + tokens.keySet().concat(", ") + "]" + ", token_number=" + "[" + tokens.values().concat(", ") + "]");
		}
		
		return parameters.concat(", ");
	}
	
	operation AbstractTask generateResourceRequirementsCode() : String {
		var genCode : String = "";
		
		for(reqItem in self.resourceRequirementItems) {
			var resourceTypeCode = "resource_type=" + reqItem.requiredResourceType.identifier;
			var requiredCapacityCode = "capacity=" + reqItem.requiredCapacity;
			
			if(reqItem.hasProperty("eligibleResourceItems")) {
				var eligibleResourcesCode : String = "";
				var eligibleReosurcesList : Sequence(String) = Sequence{};
				for(eligibleResourceItem in reqItem.eligibleResourceItems) {
					eligibleReosurcesList.add(eligibleResourceItem.eligibleResourcePtr.getResourceVariableName() + "Time(" + eligibleResourceItem.wcetOnResource + ")");
				}
				eligibleResourcesCode = "eligible_resources={" + eligibleReosurcesList.concat(", ") + "}";
				genCode += self.getTaskVariableName() + ".add_resource_requirement(" + resourceTypeCode + ", " + eligibleResourcesCode + ", " + requiredCapacityCode + ")\n";
			}
			else
				genCode += self.getTaskVariableName() + ".add_resource_requirement(" + resourceTypeCode + ", " + requiredCapacityCode + ")\n";
		}
		
		return genCode;
	}

	operation AbstractResource getResourceVariableName() : String {
		if (self.name == "System")
			return self.name.firstToUpperCase();
		return self.name.toLowerCase() + "_" + self.belongs.abstraction.asString().characterAt(0);
	}
	
	operation AbstractTask getTaskVariableName() : String {
		return self.name + "_" + self.type;
	}

	operation Sequence(AbstractResource) generateResourceTreeCode() : String {
		var genCode : String = "";
		for(compositeResource in self) {
			for(childResource in compositeResource.subResources)
				genCode += compositeResource.getResourceVariableName() + ".add(" + childResource.getResourceVariableName() + ")\n";
		}
		return genCode;
	}

	operation AbstractResource generateExclusiveResourcesCode() : String {
		var genCode : String = "";
		for(exclusiveResource in self.exclusiveResources) {
			genCode += self.getResourceVariableName() + ".add_exclusive_resource(" + exclusiveResource.getResourceVariableName() + ")\n";
		}
		return genCode;
	}

	operation AbstractResource generatePowerConsumptionCode() : String {
		var power = self.power;
		var codeGenerator : String = "pow_" + self.getResourceVariableName() + " = PowerFactory.create_instance(PowerTypeList.";
		if(power.isTypeOf(FixedStatePowerConsumption)) {
			codeGenerator += "FIXED_STATE_POWER_CONSUMPTION, " + power.maxState.scale + ", " + power.maxState.powerConsumption + ")\n";
		}
		if(power.isTypeOf(DiscreteStatePowerConsumption)) {
			codeGenerator += "DISCRETE_STATE_POWER_CONSUMPTION, " + power.minState.scale + ", " + power.minState.powerConsumption + ", " + power.maxState.scale + ", " + power.maxState.powerConsumption + ")\n";
			for(state in power.runnableStates) {
				codeGenerator += "pow_" + self.getResourceVariableName() + ".add_state(" + state.scale + ", " + state.powerConsumption + ")\n";
			}
		}
		else if(power.isTypeOf(ContinuousStatePowerConsumption)) {
			codeGenerator += "CONTINUOUS_STATE_POWER_CONSUMPTION, " + power.minState.scale + ", " + power.minState.powerConsumption + ", " + power.maxState.scale + ", " + power.maxState.powerConsumption + ")\n";
		}
		codeGenerator += self.getResourceVariableName() + ".set_power_consumption(pow_" + self.getResourceVariableName() + ")\n";
		
		return codeGenerator;
	}

	operation OrderedSet(ResourceType) getResources (abstractions : Sequence(ResourceAbstraction)) : Sequence(AbstractResource) {
		var seqResources : Sequence(ResourceT) = Sequence{};
		for(resourceType in self.select(rType | abstractions.includes(rType.abstraction))) {
			seqResources += resourceType.has.asSequence();
		}
		return seqResources;
	}
%]