
\documentclass[]{scrartcl}

\usepackage{listings}
\usepackage{color}

% Title Page
\title{Language Framework for Optimal Schedulers (LFOS)}
\subtitle{Guideline for Users}
\author{G\"{u}ner Orhan}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{backgroundcolor}{rgb}{1,1,0.95}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{backgroundcolor},	% choose the background color
	basicstyle=\footnotesize,        			% size of fonts used for the code
	breaklines=true,                 			% automatic line breaking only at whitespace
	captionpos=b,                    			% sets the caption-position to bottom
	commentstyle=\color{mygreen},    			% comment style
	escapeinside={\%*}{*)},          			% if you want to add LaTeX within your code
	keywordstyle=\color{blue},       			% keyword style
	stringstyle=\color{mymauve},    			% string literal style
	showspaces=false,                			% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          			% underline spaces within strings only
	showtabs=false,                  			% show tabs within strings adding particular underscores
	numbers=left,
}

\begin{document}
\maketitle
    
\section{Required Modules}
In order to use LFOS frameowrk API, a programmer should import the required module:

\begin{lstlisting}[language=Python, frame=single, label={lst:moduleImport}, caption={Importing required modules}]
from LFOS.Scheduler.Scheduler import Scheduler
from LFOS.Resource.Resource import *
from LFOS.Task.Task import *
from LFOS.Scheduling.Characteristic.Time import Time
from LFOS.macros import *
\end{lstlisting}
        

\section{Scheduler}
Based on the selected instance, the scheduler instance, namely ``\textsf{tsp\_scheduler}'', can be generated by following the following procedures one-by-one:
        
\subsection{Resource Initialization for ``\textsf{machine}''}
        
Since some of the task specifications are based on the resources, in the framework, a programmer is expected to define the resources, initially.
As explained in the article, some of the specifications are inevitable for a resource. Therefore, it should be defined for each resource.
Based on the feature model, the following attributes are inevitable for a resource:
\begin{itemize}
    \item \textsc{Capacity} ($\mathcal{C}$): The capacity of the resource are required to determine the maximum amount of capacity which can be utilized
    per time unit.
    \item \textsc{Type} ($\Re$): This attribute categorize the resources based on \emph{Abstractions} and \emph{Identifier}.
    \item \textsc{Mode} ($\mathcal{X}$): The mode of a resource may be either \emph{Shared} or \emph{Exclusive}.
    \item \textsc{Power Consumption} ($\mathcal{V}$): A resource consumes power based on this attribute. The resource is either \emph{Scalable} or not.
    \item \textsc{Objective} ($\mathcal{O}_\alpha$): This attribute is related with the resource-related objectives.
\end{itemize}

The only required specification for the instantiation is \emph{Type} of the resource. The default values for all specification belonging to a resource are
shown in Table \ref{tab:resource_vars_default}.

\begin{table}[!htb]
	\centering
	\begin{tabular}{r || c | c |}
		\hline
		\textbf{Feature Name} & \textbf{Variable Type} & \textbf{Initial Value} \\ \hline \hline
		Capacity ($\mathcal{C})$ & float & $0.0$ \\ \hline
		Type ($\Re$) & LFOS.Resource.Type.ResourceTypeList::Enum & \textsf{proc\_t} \\ \hline
		Mode ($\mathcal{X}$) & LFOS.Resource.Mode.ModeTypeList::Enum & \textsc{cb\_exclusive} \\ \hline
		Power Consumption ($\mathcal{V}$) & LFOS.Resource.Power & \textsf{None} \\ \hline
		Objective ($\mathcal{O}_{\alpha}$) & LFOS.Objective & \textsf{None} \\ \hline
	\end{tabular}
	\caption{Default instance variables of the \emph{Resource} module and their default values.}
	\label{tab:resource_vars_default}
\end{table}

            
For \emph{abstraction}, \textsc{active} is selected. Therefore, you can create the type object using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:activeType}, caption={Active resource type object instantiation}]
machine_t = Type(ResourceTypeList.ACTIVE, 'machine_t')
\end{lstlisting}
        
        
According to the specification, a programmer can create the resource giving type object and a name of the resource as arguments to the class method of the
ResourceFactory class shown in Listing \ref{lst:machineactiveInstantiation}. For active resources, an object belonging to \textsf{TerminalResource} class is instantiated
using factory method pattern to handle the optional feature under \emph{Abstraction} sub-feature.


\begin{lstlisting}[language=Python, frame=single, label={lst:machineactiveInstantiation}, caption={Active resource instantiation using ResourceFactory class}]
machine = ResourceFactory.create_instance(machine_t, 'machine')
\end{lstlisting}
        

\subsubsection{Setting mode}
There are three possible types for this attribute. These are:
\begin{itemize}
    \item \textsf{ModeTypeList.SHARED}
    \item \textsf{ModeTypeList.CB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.SB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.CB\_AND\_SB\_EXCLUSIVE}
\end{itemize}
The functionality of these modes are discussed in the article.

As shown in Table \ref{tab:resource_vars_default}, the mode is initially set to \textsf{ModeTypeList.CB\_EXCLUSIVE}. A programmer can change the mode of a resource by using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:machinesetMode}, caption={Setting the mode of a resource after creating a resource.}]
machine.set_mode(mode)
# mode --> ResourceTypeList::Enum
\end{lstlisting}
        

In order to check the mode of the resource, you can use the functions depicted in Listing \ref{lst:machinegetMode}.

\begin{lstlisting}[language=Python, frame=single, label={lst:machinegetMode}, caption={The functions for resource mode check.}]
machine.is_mode(mode) # mode --> ResourceTypeList::Enum
# returns True if the argument matches with the mode of the resource.

machine.is_exclusive()
# returns True if the mode of the resource is any one of the exclusive mode.
\end{lstlisting}
        
        
According to your specification, you have selected at least \textsf{CB\_EXCLUSIVE} mode for your resource ``machine''. Since the resource is set to this mode initially, you do not need to set it again.
        
\subsubsection{Setting Power Consumption}
There are three possible types of power consumption:
\begin{itemize}
    \item \textsf{PowerTypeList.FIXED\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.DISCRETE\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.CONTINUOUS\_STATE\_POWER\_CONSUMPTION}
\end{itemize}
Each of these types have their corresponding classes inheriting \textsf{Resource} class. Therefore, we have utilized factory method design pattern.
        
Since you have selected non-scalable power consumption for the resource. The following instantiation can be applied:

\begin{lstlisting}[language=Python, frame=single, label={lst:machinesettingPowerConsumption}, caption={Initializing power consumption module and setting it to the resource.}]
power_type = PowerTypeList.FIXED_STATE_POWER_CONSUMPTION
machine_pc = PowerFactory.create_instance(power_type, scale, consumption)
# Arguments: power_type --> PowerTypeList::Enum
#            scale --> float // a scale value within [0.0, 1.0]
#            consumption --> float // a power consumption of one-capacity per unit time
# it returns the instance belonging

machine.set_power_consumption(machine_pc)
\end{lstlisting}
        

If you want to get the instance of power, then you can use the following function:

\begin{lstlisting}[language=Python, frame=single, label={lst:machinegettingPowerConsumption}, caption={Getting power consumption module}]
machine.get_power_consumption()
\end{lstlisting}
        
            
All the other member functions for Power module is as follows:
            

\begin{lstlisting}[language=Python, frame=single, label={lst:machinememberFunctionsPower}, caption={The member functions for \textsf{FixedStatePowerConsumption} module.}]
FixedStatePowerConsumption.add_state(self, scale, pow_cons) -> boolean (Interface Function)
FixedStatePowerConsumption.get_active_power_state() -> dict
FixedStatePowerConsumption.get_max_power_state() -> list
FixedStatePowerConsumption.get_min_power_state() -> list
FixedStatePowerConsumption.get_power_consumption() -> float
FixedStatePowerConsumption.get_power_consumption_w_scale(scale) -> float (Interface Function)
FixedStatePowerConsumption.get_power_scale() -> float
FixedStatePowerConsumption.get_power_states() -> Numpy.array
FixedStatePowerConsumption.max_range_check(scale) -> boolean
FixedStatePowerConsumption.range_check(scale) -> boolean
FixedStatePowerConsumption.remove_state(scale) -> boolean (Interface Function)
FixedStatePowerConsumption.set_max_state(self, scale, pow_cons) -> boolean (Interface Function)
FixedStatePowerConsumption.set_min_state(scale, pow_cons) -> boolean (Interface Function)
FixedStatePowerConsumption.set_power_consumption(consumption) -> None
FixedStatePowerConsumption.set_power_mode(scale) -> boolean (Interface Function)
\end{lstlisting}
        
            
\end{document}
