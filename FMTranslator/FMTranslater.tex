
\documentclass[]{scrartcl}

\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{array}

% Title Page
\title{Language Framework for Optimal Schedulers (LFOS)}
\subtitle{Guideline for Users}
\author{G\"{u}ner Orhan}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{backgroundcolor}{rgb}{1,1,0.95}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
	backgroundcolor=\color{backgroundcolor},	% choose the background color
	basicstyle=\footnotesize,        			% size of fonts used for the code
	breaklines=true,                 			% automatic line breaking only at whitespace
	captionpos=b,                    			% sets the caption-position to bottom
	commentstyle=\color{mygreen},    			% comment style
	escapeinside={\%*}{*)},          			% if you want to add LaTeX within your code
	keywordstyle=\color{blue},       			% keyword style
	stringstyle=\color{mymauve},    			% string literal style
	showspaces=false,                			% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false,          			% underline spaces within strings only
	showtabs=false,                  			% show tabs within strings adding particular underscores
	numbers=left,
}

\begin{document}
\maketitle
    
\section{Required Modules}
In order to use LFOS frameowrk API, a programmer should import the required module:

\begin{lstlisting}[language=Python, frame=single, label={lst:moduleImport}, caption={Importing required modules}]
from LFOS.Scheduler.Scheduler import Scheduler
from LFOS.Resource.Resource import *
from LFOS.Task.Task import *
from LFOS.Scheduling.Characteristic.Time import Time
from LFOS.macros import *
\end{lstlisting}
        

\section{Scheduler}
Based on the selected instance, the scheduler instance, namely ``\textsf{sched}'', can be generated by following the following procedures one-by-one:
        
\subsection{Resource Initialization for ``\textsf{cpu1}''}
        
Since some of the task specifications are based on the resources, in the framework, a programmer is expected to define the resources, initially.
As explained in the article, some of the specifications are inevitable for a resource. Therefore, it should be defined for each resource.
Based on the feature model, the following attributes are inevitable for a resource:
\begin{itemize}
    \item \textsc{Capacity} ($\mathcal{C}$): The capacity of the resource are required to determine the maximum amount of capacity which can be utilized
    per time unit.
    \item \textsc{Type} ($\Re$): This attribute categorize the resources based on \emph{Abstractions} and \emph{Identifier}.
    \item \textsc{Mode} ($\mathcal{X}$): The mode of a resource may be either \emph{Shared} or \emph{Exclusive}.
    \item \textsc{Power Consumption} ($\mathcal{V}$): A resource consumes power based on this attribute. The resource is either \emph{Scalable} or not.
    \item \textsc{Objective} ($\mathcal{O}_\alpha$): This attribute is related with the resource-related objectives.
\end{itemize}

The only required specification for the instantiation is \emph{Type} of the resource. The default values for all specification belonging to a resource are
shown in Table \ref{tab:resource_vars_default}.

\begin{table}[!htb]
	\centering
	\begin{tabular}{r || c | c |}
		\hline
		\textbf{Feature Name} & \textbf{Variable Type} & \textbf{Initial Value} \\ \hline \hline
		Capacity ($\mathcal{C})$ & float & $0.0$ \\ \hline
		Type ($\Re$) & LFOS.Resource.Type.ResourceTypeList::Enum & \textsf{proc\_t} \\ \hline
		Mode ($\mathcal{X}$) & LFOS.Resource.Mode.ModeTypeList::Enum & \textsc{cb\_exclusive} \\ \hline
		Power Consumption ($\mathcal{V}$) & LFOS.Resource.Power & \textsf{None} \\ \hline
		Objective ($\mathcal{O}_{\alpha}$) & LFOS.Objective & \textsf{None} \\ \hline
	\end{tabular}
	\caption{Default instance variables of the \emph{Resource} module and their default values.}
	\label{tab:resource_vars_default}
\end{table}

            
For \emph{abstraction}, \textsc{active} is selected. Therefore, you can create the type object using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:activeType}, caption={Active resource type object instantiation}]
cpu1_t = Type(ResourceTypeList.ACTIVE, 'cpu1_t')
\end{lstlisting}
        
        
According to the specification, a programmer can create the resource giving type object and a name of the resource as arguments to the class method of the
ResourceFactory class shown in Listing \ref{lst:cpu1activeInstantiation}. For active resources, an object belonging to \textsf{TerminalResource} class is instantiated
using factory method pattern to handle the optional feature under \emph{Abstraction} sub-feature.


\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1activeInstantiation}, caption={Active resource instantiation using ResourceFactory class}]
cpu1 = ResourceFactory.create_instance(cpu1_t, 'cpu1')
\end{lstlisting}
        

\subsubsection{Setting mode}
There are three possible types for this attribute. These are:
\begin{itemize}
    \item \textsf{ModeTypeList.SHARED}
    \item \textsf{ModeTypeList.CB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.SB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.CB\_AND\_SB\_EXCLUSIVE}
\end{itemize}
The functionality of these modes are discussed in the article.

As shown in Table \ref{tab:resource_vars_default}, the mode is initially set to \textsf{ModeTypeList.CB\_EXCLUSIVE}. A programmer can change the mode of a resource by using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1setMode}, caption={Setting the mode of a resource after creating a resource.}]
cpu1.set_mode(mode)
# mode --> ResourceTypeList::Enum
\end{lstlisting}
        

In order to check the mode of the resource, you can use the functions depicted in Listing \ref{lst:cpu1getMode}.

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1getMode}, caption={The functions for resource mode check.}]
cpu1.is_mode(mode) # mode --> ResourceTypeList::Enum
# returns True if the argument matches with the mode of the resource.

cpu1.is_exclusive()
# returns True if the mode of the resource is any one of the exclusive mode.
\end{lstlisting}
        
        
According to your specification, you have selected at least \textsf{CB\_EXCLUSIVE} mode for your resource ``cpu1''. Since the resource is set to this mode initially, you do not need to set it again.
        
In addition to the CB\_EXCLUSIVE mode, you have selected the \textsf{SB\_EXCLUSIVE} mode for your resource ``cpu1''. Therefore, you should manually set it after resource creation using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1setCBSBExclusiveResource}, caption={The resource is set to CB\_AND\_SB\_EXCLUSIVE mode.}]
cpu1.set_mode(ModeTypeList.CB_AND_SB_EXCLUSIVE)
\end{lstlisting}
        

Due to semantic-based exclusive property of the resource, you can define exclusive resources by using the following formula:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1addSBExclusiveResource}, caption={A function for adding exclusive resources.}]
cpu1.add_exclusive_resource(resource)
# returns True if the SB\_EXCLUSIVE mode is selected and the resource argument is not in the list of exclusive resources. Otherwise, it returns False.
\end{lstlisting}
        
        
\subsubsection{Setting Power Consumption}
There are three possible types of power consumption:
\begin{itemize}
    \item \textsf{PowerTypeList.FIXED\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.DISCRETE\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.CONTINUOUS\_STATE\_POWER\_CONSUMPTION}
\end{itemize}
Each of these types have their corresponding classes inheriting \textsf{Resource} class. Therefore, we have utilized factory method design pattern.
        
You have selected continuous-state power consumption. Therefore, you can create your power consumption object with the code as follows:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1settingPowerConsumptionContinuous}, caption={Power consumption object is created for Continuous-State Power Consumption type.}]
power_type = PowerTypeList.CONTINUOUS_STATE_POWER_CONSUMPTION
cpu1_pc = PowerFactory.create_instance(power_type, scale, consumption)
# create_instance(_type, min_scale, min_pow_cons, max_scale=None, max_pow_cons=None) -> FixedStatePowerConsumption | DiscreteStatePowerConsumption | ContinuousStatePowerConsumption
# 
#         Returns the corresponding instance for given _type.
# 
#         :param _type:
#             PowerTypeList.FIXED_STATE_POWER_CONSUMPTION |
#             PowerTypeList.DISCRETE_STATE_POWER_CONSUMPTION |
#             PowerTypeList.CONTINUOUS_STATE_POWER_CONSUMPTION
#         :param min_scale: float -> minimum power scale
#         :param min_pow_cons: float -> minimum power consumption
#         :param max_scale: float -> maximum power scale
#         :param max_pow_cons: float -> maximum power consumption
#         :return: FixedStatePowerConsumption | DiscreteStatePowerConsumption | ContinuousStatePowerConsumption
\end{lstlisting}
        
       
All other member functions for the class is shown in Listing \ref{lst:cpu1memberFunctionsPowerContinuous}
            

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu1memberFunctionsPowerContinuous}, caption={The member functions for \textsf{ContinuousStatePowerConsumption} module.}]
ContinuousStatePowerConsumption.set_max_state(scale, pow_cons) -> boolean
ContinuousStatePowerConsumption.max_range_check(scale) -> boolean
ContinuousStatePowerConsumption.get_power_consumption_w_scale(scale) -> float
ContinuousStatePowerConsumption.get_active_power_state() -> dict
ContinuousStatePowerConsumption.get_max_power_state() -> list
ContinuousStatePowerConsumption.get_min_power_state() -> list
ContinuousStatePowerConsumption.get_power_states() -> Numpy.array
ContinuousStatePowerConsumption.set_min_state(scale, pow_cons) -> boolean
ContinuousStatePowerConsumption.remove_state(scale) -> boolean (Interface Function)
ContinuousStatePowerConsumption.range_check(scale) -> boolean
ContinuousStatePowerConsumption.get_power_consumption() -> float
ContinuousStatePowerConsumption.set_power_scale_precision(precision) -> None
ContinuousStatePowerConsumption.set_power_mode(scale) -> list(scale, power consumption)
ContinuousStatePowerConsumption.get_power_scale_precision() -> float
ContinuousStatePowerConsumption.__calculate_power_consumption_slope()
ContinuousStatePowerConsumption.add_state(self, scale, pow_cons) -> boolean (Interface Function)
ContinuousStatePowerConsumption.get_power_scale() -> float
\end{lstlisting}
        
            
\subsection{Resource Initialization for ``\textsf{cpu2}''}
        
For \emph{abstraction}, \textsc{active} is selected. Therefore, you can create the type object using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:activeType}, caption={Active resource type object instantiation}]
cpu2_t = Type(ResourceTypeList.ACTIVE, 'cpu2_t')
\end{lstlisting}
        
        
According to the specification, a programmer can create the resource giving type object and a name of the resource as arguments to the class method of the
ResourceFactory class shown in Listing \ref{lst:cpu2activeInstantiation}. For active resources, an object belonging to \textsf{TerminalResource} class is instantiated
using factory method pattern to handle the optional feature under \emph{Abstraction} sub-feature.


\begin{lstlisting}[language=Python, frame=single, label={lst:cpu2activeInstantiation}, caption={Active resource instantiation using ResourceFactory class}]
cpu2 = ResourceFactory.create_instance(cpu2_t, 'cpu2')
\end{lstlisting}
        

\subsubsection{Setting mode}
There are three possible types for this attribute. These are:
\begin{itemize}
    \item \textsf{ModeTypeList.SHARED}
    \item \textsf{ModeTypeList.CB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.SB\_EXCLUSIVE}
    \item \textsf{ModeTypeList.CB\_AND\_SB\_EXCLUSIVE}
\end{itemize}
The functionality of these modes are discussed in the article.

As shown in Table \ref{tab:resource_vars_default}, the mode is initially set to \textsf{ModeTypeList.CB\_EXCLUSIVE}. A programmer can change the mode of a resource by using the following code segment:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu2setMode}, caption={Setting the mode of a resource after creating a resource.}]
cpu2.set_mode(mode)
# mode --> ResourceTypeList::Enum
\end{lstlisting}
        

In order to check the mode of the resource, you can use the functions depicted in Listing \ref{lst:cpu2getMode}.

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu2getMode}, caption={The functions for resource mode check.}]
cpu2.is_mode(mode) # mode --> ResourceTypeList::Enum
# returns True if the argument matches with the mode of the resource.

cpu2.is_exclusive()
# returns True if the mode of the resource is any one of the exclusive mode.
\end{lstlisting}
        
        
According to your specification, you have selected at least \textsf{CB\_EXCLUSIVE} mode for your resource ``cpu2''. Since the resource is set to this mode initially, you do not need to set it again.
        
\subsubsection{Setting Power Consumption}
There are three possible types of power consumption:
\begin{itemize}
    \item \textsf{PowerTypeList.FIXED\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.DISCRETE\_STATE\_POWER\_CONSUMPTION}
    \item \textsf{PowerTypeList.CONTINUOUS\_STATE\_POWER\_CONSUMPTION}
\end{itemize}
Each of these types have their corresponding classes inheriting \textsf{Resource} class. Therefore, we have utilized factory method design pattern.
        
You have selected discrete-state power consumption. Therefore, you can create your power consumption object with the code as follows:

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu2settingPowerConsumptionDiscrete}, caption={Power consumption object is created for Discrete-State Power Consumption type.}]
power_type = PowerTypeList.DISCRETE_STATE_POWER_CONSUMPTION
cpu2_pc = PowerFactory.create_instance(power_type, scale, consumption)
# create_instance(_type, min_scale, min_pow_cons, max_scale=None, max_pow_cons=None) -> FixedStatePowerConsumption | DiscreteStatePowerConsumption | ContinuousStatePowerConsumption
# 
#         Returns the corresponding instance for given _type.
# 
#         :param _type:
#             PowerTypeList.FIXED_STATE_POWER_CONSUMPTION |
#             PowerTypeList.DISCRETE_STATE_POWER_CONSUMPTION |
#             PowerTypeList.CONTINUOUS_STATE_POWER_CONSUMPTION
#         :param min_scale: float -> minimum power scale
#         :param min_pow_cons: float -> minimum power consumption
#         :param max_scale: float -> maximum power scale
#         :param max_pow_cons: float -> maximum power consumption
#         :return: FixedStatePowerConsumption | DiscreteStatePowerConsumption | ContinuousStatePowerConsumption
\end{lstlisting}
        
       
All the other member functions for the object is shown in Listing \ref{lst:cpu2memberFunctionsPowerDiscrete}:
            

\begin{lstlisting}[language=Python, frame=single, label={lst:cpu2memberFunctionsPowerDiscrete}, caption={The member functions for \textsf{DiscreteStatePowerConsumption} module.}]
DiscreteStatePowerConsumption.get_power_states() -> Numpy.array
DiscreteStatePowerConsumption.set_power_mode(scale) -> list
DiscreteStatePowerConsumption.range_check(scale) -> boolean
DiscreteStatePowerConsumption.get_max_power_state() -> list
DiscreteStatePowerConsumption.get_min_power_state() -> list
DiscreteStatePowerConsumption.get_active_power_state() -> dict
DiscreteStatePowerConsumption.remove_state(scale) -> float | None
DiscreteStatePowerConsumption.max_range_check(scale) -> boolean
DiscreteStatePowerConsumption.get_power_consumption_w_scale(scale) -> float
DiscreteStatePowerConsumption.add_state(scale, pow_cons) -> boolean
DiscreteStatePowerConsumption.set_max_state(scale, pow_cons) -> boolean
DiscreteStatePowerConsumption.get_power_scale() -> float
DiscreteStatePowerConsumption.get_power_consumption() -> float
DiscreteStatePowerConsumption.set_min_state(scale, pow_cons) -> boolean
\end{lstlisting}
        
            
\section{Task Initialization for \textsf{t1}}
        
In order to create a task instance, a programmer first needs to specify the granularity of the task. A task can be specified as either \emph{terminal} or \emph{composite}. This information comes from the feature diagram.
Secondly, she has to define each mandatory keyword that is inevitable to create task instance. The task model consists of many sub-feature models. It is necessary to explain these branches to make a programmar familiar with
the terminology.
\begin{itemize}
    \item \textsc{Granularity} ($\mathcal{G}$): The granularity of a task (\emph{terminal} or \emph{composite}) that is termed as \textsf{TaskType} in the implementation.

\begin{lstlisting}[language=Python, frame=single, label={lst:TaskTypeListt1}, caption={The enumeration of the type of tasks.}]
TaskTypeList.TERMINAL
TaskTypeList.COMPOSITE
\end{lstlisting}
        
    \item \textsc{Timing} ($T$): This attribute includes all the relevant time-related task properties such as \emph{release time}, \emph{execution time}, \emph{deadline}, and \emph{period} information.
    \item \textsc{Requirement} ($\mathcal{R}$): The requirements of tasks that are \emph{Resource Requirement} and \emph{Deadline Requirement}.
    \item \textsc{Priority} ($\rho$): The priority information of a task.
    \item \textsc{Dependency} ($\Delta$): The dependency relation with respect to other tasks, which is optional.
    \item \textsc{Preemptable} ($\mathcal{P}_\tau$): The preemptability property of a task, which is optional.
    \item \textsc{Objective} ($\mathcal{O}_{\tau}$): This attribute holds the task-related objective information, which is optional.
\end{itemize}

In the second phase, a programmer should specify the values for each attribute in the feature model. The keywords and correlated information is represented in Table \ref{tab:keywords_task}
\begin{table}
\hspace{-17mm}
    \resizebox{1.2\textwidth}{!}{\begin{tabular}{ | >{\centering\arraybackslash} m{3cm} || >{\centering\arraybackslash} m{10cm} | >{\centering\arraybackslash} m{8cm} | >{\centering\arraybackslash} m{7cm}| }
        \hline \hline \textbf{Keyword} & \textbf{Type} & \textbf{Default Value} & \textbf{Description} \\ \hline		name & string & - & The name of a task \\ \hline
		periodicity & LFOS.Task.Periodicity.PeriodicityTypeList & - & The periodicty type of a task \\ \hline
		deadline\_type & LFOS.Task.Requirement.DeadlineRequirementTypeList & DeadlineRequirementTypeList.HARD & The deadline satisfaction type of a task \\ \hline
		priority & int & 0 & The priority of a task \\ \hline
		deadline & LFOS.Scheduling.Characteristic.Time & - & The deadline of a task \\ \hline
		token\_number & list(int) & [1] & The list of numbers of a specific token that would be fired. There exist one-to-one relation between the list and token\_name list with respect to index. \\ \hline
		phase & LFOS.Scheduling.Characteristic.Time & - & The first release time of a task \\ \hline
		preemptability & LFOS.Task.Preemptability.PreemptionTypeList & PreemptionTypeList.FULLY\_PREEMPTABLE & The preemptability of a task \\ \hline
		type & string & - & The type of a task \\ \hline
		token\_name & list(str) & list("\_\_$<$name$>$\_\_"] & The list of names of the token which would be fired after completion of the task instance. \\ \hline

    \end{tabular}}
    \caption{\emph{Keywords} to instantiate a task object.}
    \label{tab:keywords_task}
\end{table}
            
\subsection{Specifying the Granularity of task ``t1''}
There are two types of tasks, namely \emph{Terminal} and \emph{Composite}. These are enumerated within \textsf{TaskTypeList} as follows:

                
Since you have defined the task ``t1'' as \emph{Terminal}, you should the following line:

\begin{lstlisting}[language=Python, frame=single, label={lst:TaskTypeInstt1}, caption={Terminal task type definition.}]
task_type_t1 = TaskTypeList.TERMINAL
\end{lstlisting}
        
        
\subsubsection{Setting the time attributes}
The time-related attributes for a task is kept under \textsf{Timing} class that inherits \textsf{Periodicity} class. Since the task class also inherits from the Timing class, a programmer can set and get the values directly
from an intance of a task. The following member functions are utilized to interact with the task instance to access the timing attributes defined above:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1memberFunctionsTiming}, caption={The member functions for \textsf{Timing} module.}]
Timing.set_deadline(new_deadline) -> None
Timing.str(object='') -> string
Timing.set_release_time(new_release_time) -> None
Timing.get_release_time() -> LFOS.Scheduling.Characteristic.Time
Timing.get_deadline() -> LFOS.Scheduling.Characteristic.Time
Timing.set_period(new_period) -> boolean
Timing.set_execution_time(new_exec_time) -> None
Timing.get_period_type() -> LFOS.Scheduling.Characteristic.Time
Timing.get_period() -> LFOS.Scheduling.Characteristic.Time
Timing.get_execution_time() -> LFOS.Scheduling.Characteristic.Time
Timing.set_periodicity(_type) -> None
\end{lstlisting}
        

The periodicity types are as follows:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1PerioidictyTypeList}, caption={The \textsf{Periodicity} type enumeration.}]
PeriodicityTypeList.APERIODIC
PeriodicityTypeList.PERIODIC
PeriodicityTypeList.SPORADIC
\end{lstlisting}
        
        
Since you have classified task ``t1'' as \textsc{periodic}, you can set a parameter for this attribute as follows:
        

\begin{lstlisting}[language=Python, frame=single, label={lst:t1periodicitySetting}, caption={Periodicity for parameter is stored in the variable to use it later in instantiation.}]
periodicity_t1 = PeriodictyTypeList.PERIODIC
\end{lstlisting}
        
        
\subsubsection{Setting the priority}
The priority class is a compact small class consists of three class vairables:
\begin{itemize}
    \item \textsc{min\_priority}: the minimum value for priority value.
    \item \textsc{max\_priority}: the maximum value for priority value.
    \item \textsc{importance\_ranking}: the importance criteria stating whether ascending or descending priority values have higher privilege for a task. \textsf{PriorityRanking} class includes this enumeration attributes
    as class variables:
    
\begin{lstlisting}[language=Python, frame=single, label={lst:t1PriorityRanking}, caption={The \textsf{PriorityRanking} enumeration.}]
PriorityRanking.ASCENDING
PriorityRanking.DESCENDING
\end{lstlisting}
        
\end{itemize}
        
This class also includes three functions, two of which setting and getting the priority value, and one of which is responsible for setting the class variables:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1memberFunctionsPriority}, caption={The member functions for \textsf{Priority} module.}]
Priority.get_priority() -> int
Priority.set_class_vars(min_prio=None, max_prio=None, ranking=None) -> None (class method)
Priority.set_priority(new_prio) -> boolean
\end{lstlisting}
        
        
\section{Task Initialization for \textsf{t2}}
        
\subsection{Specifying the Granularity of task ``t1''}
There are two types of tasks, namely \emph{Terminal} and \emph{Composite}. These are enumerated within \textsf{TaskTypeList} as follows:

                
Since you have defined the task ``t1'' as \emph{Terminal}, you should the following line:

\begin{lstlisting}[language=Python, frame=single, label={lst:TaskTypeInstt1}, caption={Terminal task type definition.}]
task_type_t1 = TaskTypeList.TERMINAL
\end{lstlisting}
        
        
\subsubsection{Setting the time attributes}
The time-related attributes for a task is kept under \textsf{Timing} class that inherits \textsf{Periodicity} class. Since the task class also inherits from the Timing class, a programmer can set and get the values directly
from an intance of a task. The following member functions are utilized to interact with the task instance to access the timing attributes defined above:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1memberFunctionsTiming}, caption={The member functions for \textsf{Timing} module.}]
Timing.set_deadline(new_deadline) -> None
Timing.str(object='') -> string
Timing.set_release_time(new_release_time) -> None
Timing.get_release_time() -> LFOS.Scheduling.Characteristic.Time
Timing.get_deadline() -> LFOS.Scheduling.Characteristic.Time
Timing.set_period(new_period) -> boolean
Timing.set_execution_time(new_exec_time) -> None
Timing.get_period_type() -> LFOS.Scheduling.Characteristic.Time
Timing.get_period() -> LFOS.Scheduling.Characteristic.Time
Timing.get_execution_time() -> LFOS.Scheduling.Characteristic.Time
Timing.set_periodicity(_type) -> None
\end{lstlisting}
        

The periodicity types are as follows:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1PerioidictyTypeList}, caption={The \textsf{Periodicity} type enumeration.}]
PeriodicityTypeList.APERIODIC
PeriodicityTypeList.PERIODIC
PeriodicityTypeList.SPORADIC
\end{lstlisting}
        
        
Since you have classified task ``t1'' as \textsc{aperiodic}, you can set a parameter for this attribute as follows:
            

\begin{lstlisting}[language=Python, frame=single, label={lst:t1periodicitySetting}, caption={Periodicity for parameter is stored in the variable to use it later in instantiation.}]
periodicity_t1 = PeriodictyTypeList.APERIODIC
\end{lstlisting}
        
            
\subsubsection{Setting the priority}
The priority class is a compact small class consists of three class vairables:
\begin{itemize}
    \item \textsc{min\_priority}: the minimum value for priority value.
    \item \textsc{max\_priority}: the maximum value for priority value.
    \item \textsc{importance\_ranking}: the importance criteria stating whether ascending or descending priority values have higher privilege for a task. \textsf{PriorityRanking} class includes this enumeration attributes
    as class variables:
    
\begin{lstlisting}[language=Python, frame=single, label={lst:t1PriorityRanking}, caption={The \textsf{PriorityRanking} enumeration.}]
PriorityRanking.ASCENDING
PriorityRanking.DESCENDING
\end{lstlisting}
        
\end{itemize}
        
This class also includes three functions, two of which setting and getting the priority value, and one of which is responsible for setting the class variables:

\begin{lstlisting}[language=Python, frame=single, label={lst:t1memberFunctionsPriority}, caption={The member functions for \textsf{Priority} module.}]
Priority.get_priority() -> int
Priority.set_class_vars(min_prio=None, max_prio=None, ranking=None) -> None (class method)
Priority.set_priority(new_prio) -> boolean
\end{lstlisting}
        
        
\end{document}
